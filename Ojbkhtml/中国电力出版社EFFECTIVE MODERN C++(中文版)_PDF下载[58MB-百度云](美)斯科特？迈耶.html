中国电力出版社EFFECTIVE MODERN C++(中文版) PDF下载 (美)斯科特？迈耶 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#751981774
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#751981774
<p>书名:中国电力出版社EFFECTIVE MODERN C++(中文版)</p><p>作者:(美)斯科特？迈耶</p><p>页数:281</p><p>定价:¥99.0</p><p>出版社:中国电力出版社</p><p>出版日期:2018-04-01</p><p>ISBN:9787519817749</p><p><h2>相关资料</h2></p>[<p>
对 C   还有爱吗？理应如此！现代 C  （即 C  11/C  14）远不止是修修补补。考 虑所有的新功能，这简直是一门语言的脱胎换骨。你在寻求指导和帮助吗？那么本书 肯定就是你想找的。关于 C  ，Scott Meyers 一直是精确、质量和惊喜的代名词。
——Gerhard Kreuzer
西门子股份公司研发工程师
 
精深的专业人士很难寻觅。完美主义的传道授业——讲求策略和言简意赅的作者也是 一人难求。当你发现两者体现在同一个人身上时，你知道你找到的会是一种享受。
《Effective Modern C  》是一位完美的技术作家高山仰止的成就。它在错综复杂、 相互联系的话题之间游走，条分缕析地、意义明确地、井井有条地进行了阐明，而所 有这些都在洗练的文笔中娓娓道来。你不太可能在《Effective Modern C  》中找到
技术错误，枯燥段落，甚至偷懒的词句。
——Andrei Alexandrescu 博士，
Facebook 研究科学家，《Modern C   Design》作者
 
作为拥有超过 20 年 C   经验的人，为了充分利用现代 C  （既要习得*实践，又 要避免各种陷阱），我强烈建议你阅读本书、彻底阅读本书，并经常参考它！当然，
我从本书中学到了很多新知识！
——Nevin Liber DRW 交易集团公司高级软件工程师
C   的缔造者 Bjarne Stroustrup 如是说：“C  11 感觉像是一种新的语言。”
《Effective Modern C  》使得我们能够清楚地向日常使用 C   的软件工程师解释， 如何从 C  11/C  14 的新特性和习惯用法中受益，并和他们产生共鸣。
Scott Meyers 出品，必属精品！
——Cassio Neri FX 定量分析师，劳埃德银行集团
  Scott 掌握了从复杂性中抽出容易理解的内核这个窍门。他的 Effective C   丛书有助 于改善上一代 C   程序员的程序设计风格，而这本新书似乎定位于为
使用现代 C   的人做同样的事情。
—— Roger Orr OR/2 有限公司，ISO C   标准委员会成员
《Effective Modern C  》是提高你的现代 C   技能的上佳工具。它不仅教会你如何 使用、何时何地使用现代 C  ，而且还是有效地使用。它还解释了背后的原因何在。 毫无疑问，Scott 清晰而有见地的文字分布在 42 个经过精心思考的条款上，
使得程序员能够更好地理解这门语言。
—— Bart Vandewoestyne
研发工程师，C   爱好者
 
我喜欢 C  ，几十年来它一直是我在工作中使用的工具。而且，它的*特性比我以 前想像的更强大、更富有表现力。但是，所有这些选择都带来了一个问题： “何时以及如何应用这些特性呢？”如以往一样，Scott 的
Effective C   丛书是这个问题的明确答案。
—— Damien Watkins CSIRO 计算软件工程组组长
这是一本关于过渡到现代 C   的上佳读物，新的 C  11/14 语言特性被和 C  98 参照着描述，主题条款很容易参读，并且在每个部分末尾都给出了总结性建议。 无论对于入门还是高级的 C   开发工程师，本书都既有娱乐性又有实用性。
—— Rachel Cheng
F5 网络
 
如果你正在从 C  98/03 迁移至 C  11/14，则肯定需要 Scott 在《Effective Modern C  》中提供的极其实用而清晰的信息。如果你已经在撰写 C  11 代码， 那么可能会通过 Scott 针对该语言的主要新功能的深入讨论来发现新功能的问题 所在。无论你的情况属于哪一种，本书*值得你为阅读而付出的时间。
—— Rob Stewart Boost Steering 委员会成员（boost.org）
</p>]<p><h2>本书特色</h2></p>[<p>
想要彻底理解C  11和C  14，不可止步于熟悉它们引入的语言特性（例如，auto型别推导、移动语义、lambda表达式，以及并发支持）。挑战在于高效地运用这些特性，从而使你的软件具备正确性、高效率、可维护性和可移植性。这正是本书意欲达成的定位。它描述的正是使用C  11和C  14（即现代C  ）来编写真正卓越的软件之道。涵盖以下主题：大括号初始化、noexcept规格、完美转发，以及智能指针的make函数的优缺点。std::move、std::forward、右值引用和*引用之间的联系。编写整洁、正确，以及高效的lambda表达式的方法。std::atomic和volatile有怎样的区别，它们分别用于什么场合，以及它们和C  的并发API有何联系。“旧”C  程序设计（即C  98）中的实战要求在现代C  的软件开发中作出哪些修订。
                                        </p>]<p><h2>内容简介</h2></p>[<p>一份宏大的作品，能够带动一个领域的蓬勃发展。C   社群在相对沉寂十数年之后迎来新一波热潮，原因是，作为一门编程工具的*核心，C   的语言和标准库都出现巨大的扩展和强化。这一番大变革始自 2011，并分别在 2014、2017 持续进化。业界习惯性地将这些新版本统称为 Modern C  ，用以区别“传统”C  。作为知名书系的*作品，《Effective Modern C  》的佳质和佳评一如其早期同门作品《Effective C  》和《More Effective C  》。本书延续作者Scott Meyers 的一贯风格和质量， 其*特质就是，不但告诉我们 How，更用巨大而精良的篇幅告诉我们 Why。作者穷追猛打讲究再三的劲儿，常让我筋疲力尽，痛并快乐地爬行于某个条款之际拍案而叹：“天啊，还有下一页！”<br/>而我，是一个在 C   领域已经生活 25 年的老兵。<br/>是的，我是一个在 C   领域生活了 25 年的老兵，这意味着我具备相当的 C   能力。尽管如此，面对这号称全新语言的 Modern C  ，我时或也有力不能逮、掩卷长叹的焦躁，特别是面对 Rvalue Reference（右值引用）、Perfect Forwarding（完美转发）、Metaprogramming（元编程）、Type Deduction（类型推导）、Type Traits（型别特征） 等艰涩主题的时候。然而正是在特别艰涩的主题上你可以领受本书的巨大价值：如果你想完善根基，本书是你的*选择。这样一本好书引介到中国，需要一位好译者和一家好出版社。高博先生是非常用心的好译者，技术上和文字上学养俱佳。我和他结缘于多年前的 emails，因着他的用功和成果， 深感此书所托得人。诚如各位所见，这是一本编排与细节俱皆上乘的出版物；我曾经亲<br/> <br/><br/><br/><br/>手编排超过 50 本书，完全知道这样的呈现需要多少细琐的步骤和细心的浇灌。本书的出版质量足以标示中国计算机图书的长足进步和精益求精。侯捷White Rock </p>]<p><h2>作者简介</h2></p>[<p>20多年来，Scott Meyers的Effective C  丛书（包括《Effective C  》、《More Effecitve C  》和《Effective STL》）已经为C  程序设计指南的业界设立标杆。他清晰明了引人入胜的、对复杂技术材料进行条分缕析的阐释为他赢得了世界范围内的称誉，也使他成为一名广受欢迎的培训师、咨询顾问和会议讲师。他拥有布朗大学计算机科学专业的博士学位。</p>]<p><h2>目录</h2></p>
    
出版商声明 1
致谢 3
绪论 7
第1章 型别推导 15
条款1：理解模板型别推导 15
条款2：理解auto型别推导 23
条款3：理解decltype 28
条款4：掌握查看型别推导结果的方法 35
第2章 auto 41
条款5：优先选用auto，而非显式型别声明 41
条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法 46
第3章 转向现代C   52
条款7：在创建对象时注意区分()和{} 52
条款8：优先选用nullptr，而非0或NULL 61
条款9：优先选用别名声明，而非typedef 64
条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别 68
条款11：优先选用删除函数，而非private未定义函数 74
条款12：为意在改写的函数添加override声明 79
条款13：优先选用const_iterator，而非iterator 85
条款14：只要函数不会发射异常，就为其加上noexcept声明 89
条款15：只要有可能使用constexpr，就使用它 95
条款16：保证const成员函数的线程安全性 101
条款17：理解特种成员函数的生成机制 106
第4章 智能指针 113
条款18：使用std::unique_ptr管理具备专属所有权的资源 115
条款19：使用std::shared_ptr管理具备共享所有权的资源 120
条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr 129
条款21：优先选用std::make_unique和std::make_shared，而非直接使用new 133
条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中 141
第5章 右值引用、移动语义和完美转发 150
条款23：理解std::move和std::forward 151
条款24：区分万能引用和右值引用 156
条款25：针对右值引用实施std::move，针对万能引用实施std::forward 161
条款26：避免依万能引用型别进行重载 169
条款27：熟悉依万能引用型别进行重载的替代方案 175
条款28：理解引用折叠 187
条款29：假定移动操作不存在、成本高、未使用 193
条款30：熟悉完美转发的失败情形 196
第6章 lambda表达式 204
条款31：避免默认捕获模式 205
条款32：使用初始化捕获将对象移入闭包 212
条款33：对auto&&型别的形参使用decltype，以std::forward之 217
条款34：优先选用lambda式，而非std::bind 220
第7章 并发API 228
条款35：优先选用基于任务而非基于线程的程序设计 228
条款36：如果异步是必要的，则指定std::launch::async 232
条款37：使std::thread型别对象在所有路径皆不可联结 236
条款38：对变化多端的线程句柄析构函数行为保持关注 243
条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值 247
条款40：对并发使用std::atomic，对特种内存使用volatile 254
第8章 微调 263
条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将
其按值传递 263
条款42：考虑置入而非插入 273
 

